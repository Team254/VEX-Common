#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_5,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_6,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_7,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_8,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           driveFR,       tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port2,           driveBR,       tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port3,           driveFL,       tmotorVex393_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port4,           driveBL,       tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port5,           slideR,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           slideL,        tmotorVex393_MC29, openLoop, encoderPort, I2C_5)
#pragma config(Motor,  port7,           arm,           tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_6)
#pragma config(Motor,  port8,           intakeL,       tmotorVex393_MC29, openLoop, encoderPort, I2C_8)
#pragma config(Motor,  port9,           intakeR,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          load,          tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_7)

#pragma systemFile
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/************************************\
|*  ROBOTC Virtual World            *|
|*                                  *|
|*  DO NOT OVERWRITE THIS FILE      *|
|*  MAKE SURE TO "SAVE AS" INSTEAD  *|
\************************************/

float drTarg = 0.0;
float dlTarg = 0.0;
float aTarg = 0.0;
float aErr;
float drErr;
float dlErr;

void leftDrive(int po) {
    motor[driveFL] = motor[driveBL] = po;
}

void rightDrive(int po) {
    motor[driveFR] = motor[driveBR] = po;
}

void drivePo(int po) {
    leftDrive(po);
    rightDrive(po);
}

float getRightDrive() {
    return (nMotorEncoder[driveFR] + nMotorEncoder[driveBR])/2.0;
}

float getLeftDrive() {
    return (nMotorEncoder[driveFL] + nMotorEncoder[driveBL])/2.0;
}

float getArm() {
    return nMotorEncoder[arm];
}


void armPo(int po) {
    motor[arm] = po;
}

void shootPo(int po) {
    motor[intakeL] = motor[intakeR] = po;
}

void loadPo(int po) {
    motor[load] = po;
}

void armChng(int targ, int thresh = 2, int wait = 10) {
	aTarg += targ;
	aErr = 10000000000000000;
	while(abs(aErr) > thresh) {}
	wait1Msec(wait);
}

void driveDist(int targ, int thresh = 2, int wait = 10) {
	drTarg += targ;
	dlTarg += targ;
	drErr = 10000000000000000;
	dlErr = 10000000000000000;
	while(abs(drErr) > thresh && abs(dlErr) > thresh) {}
	wait1Msec(wait);
}

// + = turn right;
void turnDist (int targ, int thresh = 2, int wait = 50) {
	targ = ((targ/360.0)*2007);
	drTarg -= targ;
	dlTarg += targ;
	drErr = 10000000000000000;
	dlErr = 10000000000000000;
	while(abs(drErr) > thresh && abs(dlErr) > thresh) {}
	wait1Msec(wait);
}

void intake(int po = 127) {
	shootPo(-po);
	loadPo(-po);
}

void shoot(int po = 127) {
	shootPo(po);
	loadPo(po);
}

task armPID() {
    float aKp = 5.9;
    float aKi = 0.5;
    float aKd = 0.5;
    float aInt = 0;
    float aDer = 0;
    float aLErr = 0;
    while(true) {
        aErr = aTarg - getArm();
        aInt += aErr;
        if (abs(aErr) < 40) {
            aInt = 0;
        }
        aDer = aErr - aLErr;
        aLErr = aErr;
        armPo((aKp*aErr)+(aKi*aInt)+(aKd*aDer));
    }
}

task drivePID() {
    float dKp = 5.9;
    float dKi = 0.0;
    float dKd = 0.0;
    float drInt = 0;
    float dlInt = 0;
    float drDer = 0;
    float dlDer = 0;
    float drLErr = 0;
    float dlLErr = 0;
    while(true) {
        drErr = drTarg - getRightDrive();
        dlErr = dlTarg - getLeftDrive();
        drInt += drErr;
        dlInt += dlErr;
        if(abs(drErr) < 10) {
            drInt = 0;
        }
        if (abs(dlErr) == 0) {
            dlInt = 0;
        }
        drDer = drErr - drLErr;
        dlDer = dlErr - dlLErr;
        drLErr = drErr;
        dlLErr = dlErr;
        rightDrive((dKp*drErr)+(dKi*drInt)+(dKd*drDer));
        leftDrive((dKp*dlErr)+(dKi*dlInt)+(dKd*dlDer));
    }
}

void driveReset(int wait = 0) {
	nMotorEncoder[driveFL] = 0;
	nMotorEncoder[driveBL] = 0;
	wait1Msec(wait);
}

void armReset(int wait = 0) {
	nMotorEncoder[arm] = 0;
	wait1Msec(wait);
}

void init() {
		armReset();
		driveReset();
    startTask(drivePID);
    startTask(armPID);
    wait1Msec(50);
}

task main(){
    init();
    writeDebugStreamLine("Start");
    turnDist(-90);
    armChng(300);
    shootPo(127);
    driveDist(2500);
    shoot();
    wait1Msec(1000);
    intake();
    turnDist(120);
    armChng(-300);
    driveDist(1500);
    armChng(0);
    driveDist(1000);
    intake(0);
    wait1Msec(750);
    turnDist(200);
    armChng(300);
    shootPo(127);
    driveDist(1890);
    shoot();
    wait1Msec(750);
    turnDist(90);
    armChng(-300);
    intake();
    driveDist(1000);
    turnDist(15);
    armChng(300);
    shoot(0);
    driveDist(1000);
    shootPo(127);
    driveDist(2250);
    shoot();
  	writeDebugStreamLine("Done");
  	wait1Msec(1000);
  	//driveDist(10000);
  	while(true){}
}
