#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_5,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_6,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_7,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_8,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           driveFR,       tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port2,           driveBR,       tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port3,           driveFL,       tmotorVex393_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port4,           driveBL,       tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port5,           slideR,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           slideL,        tmotorVex393_MC29, openLoop, encoderPort, I2C_5)
#pragma config(Motor,  port7,           arm,           tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_6)
#pragma config(Motor,  port8,           intakeL,       tmotorVex393_MC29, openLoop, encoderPort, I2C_8)
#pragma config(Motor,  port9,           intakeR,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          load,          tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_7)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/************************************\
|*  ROBOTC Virtual World            *|
|*                                  *|
|*  DO NOT OVERWRITE THIS FILE      *|
|*  MAKE SURE TO "SAVE AS" INSTEAD  *|
\************************************/

float drTarg = 0.0;
float dlTarg = 0.0;

void leftDrive(int po) {
	motor[driveFL] = motor[driveBL] = po;
}

void rightDrive(int po) {
	motor[driveFR] = motor[driveBR] = po;
}

void drivePo(int po) {
	leftDrive(po);
	rightDrive(po);
}

float rightDrive() {
	return (nMotorEncoder[driveFR] + nMotorEncoder[driveBR])/2.0;
}

float leftDrive() {
	return (nMotorEncoder[driveFL] + nMotorEncoder[driveBL])/2.0;
}


void armPo(int po) {
	motor[arm] = po;
}

void shootPo(int po) {
	motor[intakeL] = motor[intakeR] = po;
}

void loadPo(int po) {
	motor[load] = 127;
}

task drivePID() {
	float dKp = 5.9;
	float dKi = 0.0;
	float dKd = 0.0;
	float drErr;
	float dlErr;
	float drInt = 0;
	float dlInt = 0;
	float drDer = 0;
	float dlDer = 0;
	float drLErr = 0;
	float dlLErr = 0;
	while(true) {
		drErr = drTarg - rightDrive();
		dlErr = dlTarg - leftDrive();
		drInt += drErr;
		dlInt += dlErr;
		if(drErr == 0) {
			drInt = 0;
		}
		if (dlErr == 0) {
			dlInt = 0;
		}
		drDer = drErr - drLErr;
		dlDer = dlErr - dlLErr;
		drLErr = drErr;
		dlLErr = dlErr;
		rightDrive((dKp*drErr)+(dKi*drInt)+(dKd*drDer));
		leftDrive((dKp*dlErr)+(dKi*dlInt)+(dKd*dlDer));
	}
}



task main()
{
	startTask(drivePID);
	drTarg = 1500;
	dlTarg = 1500;
}
